#!/usr/bin/env python
# coding: utf-8

# # Section 3.1: Error Handling
# * try...except
# * try...except...except...
# * try...except...else
# * try...finally
# * raise
# 
# ### Students will be able to:
# * Differentiate between exception types and recognize their meaning
# * Handle a raised exception
# * Handle different exception types
# * Use `else` and `finally` to perform clean-up actions 
# * Raise a forced exception of a specific type

# ---
# <font size="6" color="#00A0B2"  face="verdana"> <B>Concepts</B></font>  
# 
# 
# ## Exception Types
# [![view video](https://iajupyterprodblobs.blob.core.windows.net/imagecontainer/common/play_video.png)](http://edxinteractivepage.blob.core.windows.net/edxpages/f7cff1a7-5601-48a1-95a6-fd1fdfabd20e.html?details=[{"src":"http://jupyternootbookwams.streaming.mediaservices.windows.net/e2b68210-4b22-40aa-8779-d52055657b79/DEV330x-3_1a_handling_exceptions.ism/manifest","type":"application/vnd.ms-sstr+xml"}],[{"src":"http://jupyternootbookwams.streaming.mediaservices.windows.net/40a52eb2-8f94-4039-9ef8-43f98ded405f/DEV330x-3_1a_handling_exceptions.vtt","srclang":"en","kind":"subtitles","label":"english"}])
# 
# 
# You have seen many error messages generated by your programs. In Python (and many other languages), errors are also called exceptions, and they have many types. Let's examine an exception (error) and discuss the error message associated with it:
# 
# ```python
# >>> 5/0
# Traceback (most recent call last):
#   File "<stdin>", line 1, in <module>
# ZeroDivisionError: division by zero
# ```
# 
# The last line indicates that the exception is of type `ZeroDivisionError`, and also indicates that it was raised by a division by zero (5/0), which is mathematically intractable. The penultimate line indicates that the exception source is in line 1 of your code. If the expression was part of a larger code, the line number would reflect the source of the error.
# 
# In addition to `ZeroDivisionError`, the Python standard library supports many exception types. In the following examples, you will see some exception types that you might have encountered already. More information about the built-in exception types is available from the Python Documentation site at https://docs.python.org/3/library/exceptions.html#bltin-exceptions.
# 
# Generally speaking, when Python encounters an error of any type it raises an exception. The exception then propagates through the calling function and upper-level functions until it's dealt with. As a programmer, you can decide what to do when an exception is raised--you can either pass it to another level or handle it. In the next section, you will explore methods of handling different types of exceptions.

# ---
# <font size="6" color="#00A0B2"  face="verdana"> <B>Examples</B></font>
# 
# ### `IndexError`
# Raised by trying to access (or write into) an out-of-range index of a sequence (i.e. list).

# In[1]:


lst = [0, 1, 2]
print(lst[30])


# ### `NameError`
# Raised by accessing an unspecified (undefined) variable.

# In[2]:


# x is not defined anywhere
print(x)


# ### `TypeError`
# Raised when performing an unsupported operation on a specific type, such us dividing strings.

# In[3]:


s1 = 'Word1'
s2 = 'Word2'
s1/s2


# ---
# <font size="6" color="#B24C00"  face="verdana"> <B>Task 1</B></font>
# 
# ## Exception Types
# 
# Before completing this task, visit the Python Documentation site at https://docs.python.org/3/library/exceptions.html#bltin-exceptions to learn about the built-in exception types.

# In[6]:


# [ ] Write an expression to raise a `ModuleNotFoundError` exception

import keyboard


# In[5]:


# [ ] Write an expression to raise an `ImportError` exception

from math import phone


# ---
# <font size="6" color="#00A0B2"  face="verdana"> <B>Concepts</B></font>  
# 
# 
# ## Handling Exceptions
# [![view video](https://iajupyterprodblobs.blob.core.windows.net/imagecontainer/common/play_video.png)](http://edxinteractivepage.blob.core.windows.net/edxpages/f7cff1a7-5601-48a1-95a6-fd1fdfabd20e.html?details=[{"src":"http://jupyternootbookwams.streaming.mediaservices.windows.net/68e9950f-11d3-4f6e-89d1-ea13946eff39/DEV330x-3_1b_handling_exceptions.ism/manifest","type":"application/vnd.ms-sstr+xml"}],[{"src":"http://jupyternootbookwams.streaming.mediaservices.windows.net/0b26fbf7-6c47-46e4-ba22-8cbc80cda57c/DEV330x-3_1b_handling_exceptions.vtt","srclang":"en","kind":"subtitles","label":"english"}])
# 
# Up to this point in the course, if your code encountered an error it stopped execution and displayed an error message. You had to read the error message, understand the reason it was generated, and fix the code. 
# 
# There are situations in which you want your code to continue execution or display a friendly message to the user despite an error that you might or might not anticipate in advance. It is possible to modify your program to handle specific exceptions and to continue execution without stopping. The process is called exception handling, and can be done using a `try...except` statement with the following syntax:
# 
# ```python
# try:
#     code that may raise an exception
# except ExceptionType:
#     code block to handle exception
# ```
# 
# #### Handling multiple exceptions
# Your program can raise exceptions of different types. You can use the `try...except` statement to handle each of the types differently by adding another `except` clause and its associated code at the end:
# 
# ```python
# try:
#     code that may raise an exception
# except ExceptionType_1:
#     code block to handle exception of type ExceptionType_1
# except ExceptionType_2:
#     code block to handle exception of type ExceptionType_2
# ```
# 
# When an exception is raised, the rest of the code inside the `try` block is ignored and the execution jumps to the relevant `except` code block and executes it. Then the program continues normal execution.
# 
# #### Handling unexpected exceptions
# If your code encounters an exception you did not anticipate or explicitly handle, your program will stop execution and display an error message. You can handle unexpected exceptions using an `except` clause without specifying the exception type:
# 
# ```python
# try:
#     code that may raise an exception
# except ExceptionType_1:
#     code block to handle exception of type ExceptionType_1
# except ExceptionType_2:
#     code block to handle exception of type ExceptionType_2
# except:
#     code block to handle unexpected exceptions of any type
# ```
# 
# #### Handling exceptions raised by other functions
# When a function raises an exception without handling it, the caller function must handle the exception or raise it up another level. For example, the `sqrt` function from the `math` module expect a positive number for an argument. Passing a negative number to `sqrt` will raise a `ValueError` exception. The `sqrt` function doesn't handle the exception internally, so your code should handle it or raise it to an upper level.
# 
# #### Error messages
# The error message associated with a raised exception can be stored in a variable using (`as exception_object:`) in the `except` clause, right after the exception type:
# 
# ```python
# try:
#     code that may raise an exception
# except ExceptionType_1 as exception_object:
#     code block to handle exception of type ExceptionType_1
# except ExceptionType_2 as exception_object:
#     code block to handle exception of type ExceptionType_2
# except Exception as exception_object:
#     code block to handle unexpected exceptions of any type
# ```
# 
# NOTE: For unexpected exceptions, use (`Exception as exception_object:`) to store the error message.

# ---
# <font size="6" color="#00A0B2"  face="verdana"> <B>Examples</B></font>
# 

# ### Handling a single exception
# 
# In this example, you will see how to handle the division by zero exception you saw earlier. You will see that the program does not terminate when it encounters the error, and continues running as expected.

# In[7]:


try:
    5/0
except ZeroDivisionError:
    print("Cannot divide by zero!")

print("Program is still running")


# ### Handling multiple exceptions
# The following example shows a program that divides all the elements of a list by their associated indices. You can see that when an exception is raised, the program ignores the rest of the code inside the `try` block (`print("print executed")`), jumps to the relevant `except` code block, and executes it. Then the program continues normal execution, so it goes through the next loop iteration and executes the `try` block again.

# In[8]:


lst = ['text', 5, 12]
for i in range(5):
    try:        
        print(lst[i] / i)
        print("print executed")
    except TypeError:
        print("Cannot divide strings")
    except IndexError:
        print("Cannot access out of range elements")


# ### Handling unexpected exceptions
# 
# If a program encounters unhandled exceptions, it will terminate and display an error message.

# In[11]:


# Without handling unexpected exception

x = [5]
try:
    x / 0
except ZeroDivisionError:
    print("Cannot divide by zero!")
    


# In[12]:


# Handling unexpected exception

x = [5]
try:
    x / 0
except ZeroDivisionError:
    print("Cannot divide by zero!")
except:
    print("Unexpected error")


# ### Handling multiple and unexpected exceptions
# 
# In the following example, the number 12 is divided by the elements of `old_lst`. The code encounters several exceptions (`TypeError`, `ZeroDivisionError`, and `IndexError`) that it handles explicitly by type. The code never stops running. When an unexpected exception (`IndexError`) is raised, the last `except` clause handles it by displaying a friendly error message.

# In[13]:


old_lst = [6, 'word', [2, 5], 0, 3]
new_lst = []

for i in range(6):
    try:
        tmp = 12 / old_lst[i]
        new_lst.append(tmp)
        print("List appended with", tmp)
    except TypeError:
        print("Cannot divide {0:d} by {1:}".format(12, type(old_lst[i])))
    except ZeroDivisionError:
        print("Cannot divide by 0")
    # Handling unexpected exceptions, by showing the associated error message
    except Exception as exception_object:
        print("Unexpected error: {0:}".format(exception_object))
        
print()
print("The new list is:", new_lst)
        


# ### Handling exceptions raised by other functions
# The `sqrt` function from the `math` module expect a positive number for an argument. Passing a negative number to `sqrt` will raise a `ValueError` exception. The `sqrt` function doesn't handle the exception internally, so your code should handle it or raise it to an upper level.

# In[14]:


# Without exception handling

from math import sqrt
x = -3
sqrt(x)


# In[15]:


# With exception handling

from math import sqrt
x = -3
try:
    sqrt(x)
except ValueError as exception_object: # Storing the error message in exception_object
    print(exception_object)


# ---
# <font size="6" color="#B24C00"  face="verdana"> <B>Task 2</B></font>
# 
# ## Handling Exceptions
# 

# In[19]:


# [ ] The following program adds `lst1` to `lst2` element by element
# Find all exceptions that will be generated by this program,
# then handle the exceptions by displaying meaningful messages.
# You should also handle unexpected exceptions.

lst1 = [-4, -5,   6,   [6], "hello"]
lst2 = [ 5, 16, [6], "hello", "goodbye"]

for i in range(7):
    try:
        print(lst1[i] + lst2[i])
    except TypeError as e:
        print('TypeError:', e)
    except IndexError as e:
        print('IndexError:', e)
    except Exception as e:
        print(e)
print("Done!")


# In[23]:


# [ ] The following program asks the user for an integer then prints the result of dividing it by 2.
# If the user enters an invalid value (i.e. "4.3" or "Hello"), the program terminates.
# Use exception handling to deal with unexpected user input and display a meaningful message.

x = input("Enter an integer: ")
try:
    x = int(x)
    print("{:d} / 2 = {:.2f}".format(x, x / 2))
except Exception as e:
    print(e)
print("Done!")


# ---
# <font size="6" color="#00A0B2"  face="verdana"> <B>Concepts</B></font>  
# 
# 
# ## `else` and `finally`
# [![view video](https://iajupyterprodblobs.blob.core.windows.net/imagecontainer/common/play_video.png)](http://edxinteractivepage.blob.core.windows.net/edxpages/f7cff1a7-5601-48a1-95a6-fd1fdfabd20e.html?details=[{"src":"http://jupyternootbookwams.streaming.mediaservices.windows.net/1b846a47-9f55-4809-8263-2f7854b75e54/DEV330x-3_1c_else_finally.ism/manifest","type":"application/vnd.ms-sstr+xml"}],[{"src":"http://jupyternootbookwams.streaming.mediaservices.windows.net/5e5e53e1-8d51-4964-a8d2-175179f5840c/DEV330x-3_1c_else_finally.vtt","srclang":"en","kind":"subtitles","label":"english"}])
# 
# #### `else`
# 
# Occasionally, you might want to run some code when a `try` statement does not raise an exception. This can be achieved using the optional `else` statement. The code block within the `else` statement will be executed when the code reaches the end of the `try` code block without raising any exceptions. 
# 
# Use the following syntax for an `else` clause:
# 
# ```python
# try:
#     code that may raise an exception
# except ExceptionType_1:
#     code block to handle exception of type ExceptionType_1
# except ExceptionType_2:
#     code block to handle exception of type ExceptionType_2
# except:
#     code block to handle unexpected exceptions of any type
# else:
#     code block to run when no exceptions were raised
# ```
# 
# #### `finally`
# 
# Sometimes you need to execute some code whether or not an exception has been raised. The optional `finally` clause can handle this situation and run a code block whenever you exit a `try...except` statement. The code block within the `finally` statement will be executed in the following situations: when an exception has been raised, upon reaching the end of the `try` statement without raising an exception, and when exiting a `try` statement by using `break`, `continue`, or `return`.
# 
# `finally` is typically used for clean-up actions, i.e. releasing external resources such as files or network connections.
# 
# Use the following syntax for a `finally` clause:
# 
# ```python
# try:
#     code that may raise an exception
# except ExceptionType_1:
#     code block to handle exception of type ExceptionType_1
# except ExceptionType_2:
#     code block to handle exception of type ExceptionType_2
# except:
#     code block to handle unexpected exceptions of any type
# finally:
#     code that will always execute whether an exception was raised or not
# ```
# 
# NOTE: Though Python allows you to use an `else` clause followed by a `finally` clause, the code generated will be difficult to understand and you should avoid using these two clauses together.
# 

# ---
# <font size="6" color="#00A0B2"  face="verdana"> <B>Examples</B></font>
# 
# ### `else`
# In this example, the code performs 3 &divide; 2 successfully and without exceptions. Therefore, the `else` clause will be executed, displaying the "All good" message.

# In[25]:


x = 3
y = 2
try:
    print(x/y)
except ZeroDivisionError:
    print("Cannot divide by zero")
else:
    print("All good! No exceptions were raised.")


# ### `finally`
# In the following examples, the code performs 3 &divide; 2, which does NOT raise an exception, and then performs 3 &divide; 0, which does raise an exception. In both cases, the `finally` clause will be executed.

# In[26]:


x = 3
y = 2
try:
    print(x/y)
except ZeroDivisionError:
    print("Cannot divide by zero")
finally:
    print("Code that will run whether an exception was raised or not")


# In[27]:


x = 3
y = 0
try:
    print(x/y)
except ZeroDivisionError:
    print("Cannot divide by zero")
finally:
    print("Code that will run whether an exception was raised or not")


# ---
# <font size="6" color="#B24C00"  face="verdana"> <B>Task 3</B></font>
# 
# ## `else` and `finally`

# ### `else`

# In[29]:


# [ ] The following program asks the user for an integer `x` then assigns `y` as the result of dividing `x` by 2.
# If the user enters an invalid value (i.e. "4.3" or "Hello"), the program terminates.
# Use exception handling to deal with unexpected user inputs, then use an `else` clause to calculate the value of `y`.

x = input("Enter an integer: ")
y = None
try:
    x = int(x)
except Exception as e:
    print(e)
else:
    y = x / 2;

if y is not None:
    print("No exceptions were raised, you can use y =", y)
else:
    print("An exception was raised, y cannot be used")


# ### `finally`

# In[43]:


# [ ] The following program tries to write to a file opened for reading.
# The program will terminate before closing the file, and the file resources will not be released.
# Use exception handling with a `finally` clause to make sure the file is closed.

# Open a text file for reading
f = open("parent_dir/text_file.txt", 'r')

# Try to write to a file open for reading (will raise an exception)
try:
    f.write("This string will not be written")
except Exception as e:
    print(e)
finally:
    f.close()
    print("File closed")
# Close the file (will not be reached if an exception was raised)


# ---
# <font size="6" color="#00A0B2"  face="verdana"> <B>Concepts</B></font>  
# 
# 
# ## Raising Exceptions
# [![view video](https://iajupyterprodblobs.blob.core.windows.net/imagecontainer/common/play_video.png)](http://edxinteractivepage.blob.core.windows.net/edxpages/f7cff1a7-5601-48a1-95a6-fd1fdfabd20e.html?details=[{"src":"http://jupyternootbookwams.streaming.mediaservices.windows.net/069a5822-5d88-4bef-afce-db108e5535f4/DEV330x-3_1d_raising_exceptions.ism/manifest","type":"application/vnd.ms-sstr+xml"}],[{"src":"http://jupyternootbookwams.streaming.mediaservices.windows.net/10ee97e5-ae30-4785-b2f8-bf4b90e5ec76/DEV330x-3_1d_raising_exceptions.vtt","srclang":"en","kind":"subtitles","label":"english"}])
# 
# In the previous examples, you saw that Python supports many built-in exceptions. As a programmer, you can also define and raise a forced exception using the `raise` statement. The syntax for this statement is:
# 
# ```python
# raise ExceptionType("Error Message")
# ```
# 
# * The `ExceptionType` can be one of the built-in exceptions supported by Python, or you can define a new type. 
# * The `Error Message` will be associated with this exception when it is raised.

# ---
# <font size="6" color="#00A0B2"  face="verdana"> <B>Examples</B></font>
# 
# You can raise an exception when a user does not provide a valid response to a request for input between 1 and 10. However, numbers outside the range do not necessarily generate errors in Python, so you have to explicitly force a raised exception.
# 
# Test the code with the following inputs:
# * 100 (an out-of-range value that should raise the forced exception)
# * text (a string value that will cause the `int()` function to raise a different `ValueError`)
# * 4 (a valid number within the range)

# In[1]:


valid = False
while not valid:
    try:
        x = int(input("Enter a number between 1 and 10: "))
        if ((x < 1) or (x > 10)):
            raise ValueError("The number is outside of the acceptable range")
        valid = True
    except ValueError as except_object:
        print("{}".format(except_object))

print("{:d} was accepted".format(x))


# #### Raising an exception in a function
# 
# The input validity test can be reorganized into a function that raises a `ValueError` exception without handling it. The calling function will receive  the raised exception and handle it.
# 
# Test the code with the following inputs:
# * 100 (an out-of-range value that should raise the forced exception)
# * text (a string value that will cause the `int()` function to raise a different `ValueError`)
# * 4 (a valid number within the range)

# In[2]:


def isValid(num):
    if ((num < 1) or (num > 10)):
        raise ValueError("The number is outside of the acceptable range")
    else:
        return num

valid = False
while not valid:
    try:
        x = int(input("Enter a number between 1 and 10: "))
        x = isValid(x)
        valid = True
    except ValueError as except_object:
        print("{}".format(except_object))

print("{:d} was accepted".format(x))


# ---
# <font size="6" color="#B24C00"  face="verdana"> <B>Task 4</B></font>
# 
# ## Raising Exceptions

# ### User input

# In[3]:


# [ ] Write a program to keep prompting the user for an odd positive number until a valid number is entered.
# Your program should raise an exception with an appropriate message if the input is not valid.
while True:
    try:
        x = int(input())
        if 1 <= x <= 10:
            break
        else:
            raise ValueError("Number is outside valid range")
    except Exception as e:
        print(e)
print(x, 'is valid, thank you')


# In[5]:


# [ ] Complete the function `isValid` to test the validity of a user input. A valid input should be an odd positive integer.
# The function should raise an exception with an appropriate message if the input is not valid.
# The function need not handle the exception.


def isValid(num):
    if num % 2 != 0 and num > 0 and type(num) == int:
        return(num)
    else:
        raise ValueError("Number is not valid")

valid = False
while not valid:
    try:
        x = int(input("Enter an odd positive number: "))
        x = isValid(x)
        valid = True
    except ValueError as except_object:
        print("{}".format(except_object))
    except Exception as e:
        print(e)

print("{:d} was accepted".format(x))

